# 5.你管这破玩意叫IO多路复用？

### 什么是文件

程序员使用I/O最终都逃不过文件。&#x20;

因为这篇同属于高性能、高并发系列，讲到高性能、高并发就离不开Linux/Unix，因此这里就来讨论一下Linux世界中的文件。&#x20;

实际上对于程序员来说文件是一个很简单的概念，我们只需要将其理解为一个N byte的序列就可以了：&#x20;

<mark style="background-color:blue;">b1, b2, b3, b4, ....... bN</mark>&#x20;

实际上所有的I/O设备都被抽象为了文件这个概念，**一切皆文件**，Everything isFile，磁盘、网络数据、终端，甚至进程间通信工具管道pipe等都被当做文件对待。

![](.gitbook/assets/5_1.jpg)

所有的I/O操作也都是通过文件读写来实现的，**这一非常优雅的抽象可以让程序员使用一套接口就能实现所有I/O操作**。&#x20;

常用的I/O操作接口一般有以下几类：

* 打开文件，open
* 改变读写位置，seek
* 文件读写，read、write
* 关闭文件，close

程序员通过这几个接口几乎可以实现所有I/O操作，这就是文件这个概念的强大之处。

### 文件描述符

在本篇第二节I/O过程中我们讲到，要想读取比如磁盘数据我们需要指定一个buff用来装入数据，是这样用的：

```
read(buff);
```

但是这里我们忽略了一个问题，那就是虽然我们执行了往哪里写数据，但是我们该从哪里读数据呢？ 从上一节中我们知道，通过文件这个概念我们能实现几乎所有I/O操作，**因此这里少的一个主角就是文件**。&#x20;

那么我们一般都怎么使用文件呢？

![](.gitbook/assets/5_2.jpg)

如果你周末去比较火的餐厅吃饭应该会有体会，一般周末这样的餐厅都会排队，然后服务员会给你一个排队序号，通过这个序号服务员就能找到你，这里的好处就是服务员无需记住你是谁、你的名字是什么、是不是保护环境爱好小动物等等，这里的关键点就是**服务员对你一无所知，但是依然可以通过一个号码就能找到你**。&#x20;

同样的，在Linux世界使用文件，我们也需要借助一个号码，根据“弄不懂原则”，这个号码就被称为了文件描述符file descriptors，在Linux世界中鼎鼎大名，其道理和上面那个排队号码一样。&#x20;

因此，文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。

![](.gitbook/assets/5_3.jpg)

有了文件描述符，进程对文件一无所知，比如文件在磁盘的什么位置上、内存是如何管理文件的等等，这些信息属于操作系统，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。&#x20;

因此我们来完善上述程序：

```
int fd = open(file_name);
read(fd, buff);
```

怎么样，是不是非常简单。

### 文件描述符太多了怎么办

经过了这么多的铺垫，终于到高性能、高并发这一主题了。&#x20;

从前几节我们知道，所有I/O操作都可以通过文件样的概念来进行，这当然包括网络通信。&#x20;

如果你是一个web服务器，当三次握手成功以后，我们通过调用accept同样会得到一个文件描述符，只不过这个文件描述符是用来进行网络通信的，通过读写该文件描述符你就可以同客户端通信。在这里为了概念上好理解，我们称之为链接描述符，通过这个描述符我们就可以读写客户端的数据了。

```
int conn_fd = accept(...);
```

server的处理逻辑通常是读取客户端请求数据，然后执行某些特定逻辑：

```
if(read(conn_fd, request_buff) > 0) {
   do_something(request_buff);
}
```

是不是非常简单，然而世界终归是复杂的，也不是这么简单的。&#x20;

接下来就是比较复杂的了。

![](.gitbook/assets/5_4.jpg)

既然我们的主题是高并发，那么server端就不可能只和一个客户端通信，而是成千上万个客户端。这时你需要处理不再是一个描述符这么简单，而是有可能要处理成千上万个描述符。&#x20;

为了不让问题一上来就过于复杂，我们先简单化，假设只同时处理两个客户端的请求。&#x20;

有的同学可能会说，这还不简单，这样写不就行了：

```
if(read(socket_fd1, buff) > 0) { // 处理第一个
   do_something();
}
if(read(socket_fd2, buff) > 0) {
   do_something();
```

在本篇第二节中我们讨论过这是非常典型的阻塞式I/O，如果读取第一个请求进程被阻塞而暂停运行，那么这时我们就无法处理第二个请求了，即使第二个请求的数据已经就位，这也就意味着所有其它客户端必须等待，而且通常情况下也不会只有两个客户端而是成千上万个，上万个连接也要这样串行处理吗。&#x20;

聪明的你一定会想到使用多线程，为每个请求开启一个线程，这样一个线程被阻塞不会影响到其它线程了，注意，既然是高并发，那么我们要为成千上万个请求开启成千上万个线程吗，大量创建销毁线 程会严重影响系统性能。&#x20;

那么这个问题该怎么解决呢？&#x20;

**这里的关键点在于在进行I/O时，我们并不知道该文件描述对于的I/O设备是否是可读的、是否是可写的**，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。&#x20;

因此要优雅的解决这个问题，就要从其它角度来思考这个问题了。

![](.gitbook/assets/5_5.jpg)

### 不要打电话给我，有需要我会打给你

大家生活中肯定会接到过推销电话，而且不止一个，一天下来接上十个八个推销电话你的身体会被掏空的。&#x20;

这个场景的关键点在于打电话的人并不知道你是不是要买东西，只能来一遍遍问你，因此一种更好的策略是不要让他们打电话给你，记下他们的电话，有需要的话打给他们。&#x20;

也就是不要打电话给我，有需要我会打给你。&#x20;

在这个例子中，你，就好比内核，推销者就好比应用程序，电话号码就好比文件描述符，和你用电话沟通就好比I/O。&#x20;

现在你应该明白了吧，处理多个文件描述符的更好方法其实就存在于推销电话中。&#x20;

因此相比上一节中我们通过I/O接口主动问内核这些文件描述符对应的外设是不是已经就绪了，一种更好的方法是，我们把这些内核一股脑扔给内核，并霸气的告诉内核：“我这里有1万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？”&#x20;

这样应用程序就从“繁忙”的主动变为清闲的被动了，反正哪些设备ok了内核会通知我， 能偷懒我才不要那么勤奋。

![](.gitbook/assets/5_6.jpg)

这是一种不同的处理I/O的机制，同样需要起一个名字，再次祭出“弄不懂原则”，就叫I/O多路复用吧，这就是 I/O multiplexing。

### I/O多路复用，I/O multiplexing

multiplexing一词其实多用于通信领域，为了充分利用通信线路，希望在一个信道中传输多路信号，要想在一个信道中传输多路信号就需要把这多路信号结合为一路，将多路信号组合成一个信号的设备被称为multiplexer，显然接收方接收到这一路组合后的信号后要恢复原先的多路信号，这个设备被称为demultiplexer，如图所示：

![](.gitbook/assets/5_7.jpg)

回到我们的主题。&#x20;

所谓I/O多路复用指的是这样一个过程：

1. 我们拿到了一堆文件描述符(不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)&#x20;
2. 通过调用**某个函数**告诉内核：“**这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回**”
3. 当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。

那么有哪些函数可以用来进行I/O多路复用呢？&#x20;

在Linux世界中有这样三种机制可以用来进行I/O多路复用：

* select
* poll
* epoll

接下来我们就简单介绍一下牛掰的I/O多路复用三剑客。

![](.gitbook/assets/5_8.jpg)

### I/O多路复用三剑客

本质上select、poll、epoll都是阻塞式I/O，也就是我们常说的同步I/O。

#### select：初出茅庐

在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合拷贝到内核中，我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个，因此程序员必须再遍历一边找到具体是哪个文件描述符可以读写了。&#x20;

因此，总结下来select有这样几个特点：

* 我能照看的文件描述符数量有限，不能超过1024个
* 用户给我的文件描述符需要拷贝的内核中
* 我只能告诉你有文件描述符满足要求了，但是我不知道是哪个，你自己一个一个去找吧(遍历)

因此我们可以看到，select机制的特性在高性能网络服务器动辄几万几十万并发链接的场景下无疑是低效的。

![](.gitbook/assets/5_9.jpg)

#### poll：小有所成

poll和select是非常相似的，poll相对于select的优化仅仅在于解决了文件描述符不能超过1024个的限制，select和poll都会随着监控的文件描述增加而出现性能下降，因此不适合高并发场景。

#### epoll：独步天下

在select面临的三个问题中，文件描述数量限制已经在poll中解决了，剩下的两个问题呢？&#x20;

针对第一个epoll使用的策略是**各个击破**与**共享内存**。

实际上文件描述符集合变化的频率比较低，select和poll频繁的拷贝整个集合，内核都快要烦死了，epoll通过引入epoll\_ctl很体贴的做到了只操作那些有变化的文件描述符，同时epoll和内核还成为了好朋友，共享了同一块内存，这块内存中保存的就是那些已经可读或者可写的的文件描述符集合，这样就减少了内核和程序的内存拷贝开销。&#x20;

针对第二点，epoll使用的策略是“当小弟”。&#x20;

在select和poll机制下，进程要亲自下场去各个文件描述符上等待，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。&#x20;

但epoll就懂事多了，主动找到进程要当小弟替大哥出头。

![](.gitbook/assets/5_10.jpg)

在这种机制下，进程不需要亲自下场了，进程只要等待在epoll上，epoll代替进程去各个文件描述符 上等待，当哪个文件描述符可读或者可写的时候就告诉epoll，epoll用小本本认真记录下来然后唤醒大哥：“进程大哥，快醒醒，你要处理的文件描述符我都记下来了”，这样进程被唤醒后就无需自己从 头到尾检查一遍，因为epoll都已经记下来了。&#x20;

因此我们可以看到，在这种机制下，实际上利用的就是“不要打电话给我，有需要我会打给你”，这就 不需要一遍一遍像孙子一样问各个文件描述符了，而是翻身做主人当大爷了，“你们那个文件描述符 可读或者可写了主动报上来”，这中机制实际上就是大名鼎鼎的事件驱动，event-driven，这也是我们 下一篇的主题。&#x20;

实际上在Linux平台，**epoll基本上就是高并发的代名词**。&#x20;

限于篇幅，关于epoll的详细使用方法就不在这里讲解了。

### 总结

基于一切皆文件的设计哲学，I/O也可以通过文件的形式实现，显然高并发要与多个文件交互，这就离不开高效的I/O多路复用技术，本文我们详细讲解了什么是I/O多路复用以及使用方法，这其中以epoll为代表的I/O多路复用(基于事件驱动)技术使用非常广泛，实际上你会发现但凡涉及到高并发、高性能都能见到事件驱动的编程方法，这也是下一篇的主题，敬请期待。
