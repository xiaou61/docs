# 10.彻底理解回调函数

不知你是不是也有这样的疑惑，我们为什么需要回调函数这个概念呢？直接调用函数不就可以了？回 调函数到底有什么作用？为什么回调函数正在变得越来越重要？&#x20;

这篇文章就来为你解答这些问题，读完这篇文章后你的武器库将新增一件功能强大的利器。

### 一切要从这样的需求说起

假设你们公司要开发下一代国民App“明日油条”，一款主打解决国民早餐问题的App，为了加快开发进度，这款应用由A小组和B小组协同开发。&#x20;

其中有一个核心模块由A小组开发然后供B小组调用，这个核心模块被封装成了一个函数，这个函数就叫make\_youtiao()。&#x20;

如果make\_youtiao()这个函数执行的很快并可以立即返回，那么B小组的同学只需要：

1. 调用make\_youtiao()
2. 等待该函数执行完成
3. 该函数执行完后继续后续流程

从程序执行的角度看这个过程是这样的：

1. 保存当前被执行函数的上下文
2. 开始执行make\_youtiao()这个函数
3. make\_youtiao()执行完后，控制转回到调用函数中

![](.gitbook/assets/10_1.jpg)

如果世界上所有的函数都像make\_youtiao()这么简单，那么程序员大概率就要失业了，还好程序的世界是复杂的，这样程序员才有了存在的价值。

### 现实情况并不容易

现实中make\_youtiao()这个函数需要处理的数据非常庞大，假设有10000个，**那么make\_youtiao(10000)不会立刻返回**，而是可能需要10分钟才执行完成并返回。&#x20;

这时你该怎么办呢？想一想这个问题。

可能有的同学就像把头埋在沙子里的鸵鸟一样：和刚才一样直接调用不可以吗，这样多简单。&#x20;

是的，这样做没有问题，但就像爱因斯坦说的那样“一切都应该尽可能简单，但是不能过于简单”。&#x20;

想一想直接调用会有什么问题？&#x20;

显然直接调用的话，那么调用线程会被阻塞暂停，在等待10分钟后才能继续运行。在这10分钟内该线程不会被操作系统分配CPU，也就是说该线程得不到任何推进。&#x20;

这并不是一种高效的做法。没有一个程序员想死盯着屏幕10分钟后才能得到结果。&#x20;

那么有没有一种更加高效的做法呢？

想一想我们上一篇中那个一直盯着你写代码的老板(见《从小白到高手，你需要理解同步与异步》)， 我们已经知道了这种**一直等待直到另一个任务完成的模式**叫做同步。&#x20;

如果你是老板的话你会什么都不干一直盯着员工写代码吗？因此一种更好的做法是程序员在代码的时 候老板该干啥干啥，程序员写完后自然会通知老板，这样老板和程序员都不需要相互等待，这种模式 被称为异步。&#x20;

回到我们的主题，这里一种更好的方式是**调用make\_youtiao()这个函数后不再等待这个函数执行完成**，而是直接返回继续后续流程，这样A小组的程序就可以和make\_youtiao()这个函数同时进行了， 就像这样：

![](.gitbook/assets/10_2.jpg)

在这种情况下，回调(callback)就必须出场了。&#x20;

### 为什么我们需要回调callback&#x20;

有的同学可能还没有明白为什么在这种情况下需要回调，别着急，我们慢慢讲。&#x20;

假设我们“明日油条”App代码第一版是这样写的：

```
make_youtiao(10000);
sell();
```

可以看到这是最简单的写法，意思很简单，制作好油条后卖出去。

![](.gitbook/assets/10_3.jpg)

我们已经知道了由于make\_youtiao(10000)这个函数10分钟才能返回，你不想一直死盯着屏幕10分钟等待结果，那么一种更好的方法是让make\_youtiao()这个函数知道制作完油条后该干什么，即，更好的调用make\_youtiao的方式是这样的：“制作10000个油条，**炸好后卖出去**”，因此调用make\_youtiao就变出这样了：

```
make_youtiao(10000, sell);
```

看到了吧，现在make\_youtiao这个函数多了一个参数，除了指定制作油条的数量外**还可以指定制作好后该干什么**，第二个被make\_youtiao这个函数调用的函数就叫回调，callback。&#x20;

现在你应该看出来了吧，虽然sell函数是你定义的，但是这个函数却是被其它模块调用执行的，就像这样：

![](.gitbook/assets/10_4.jpg)

make\_youtiao这个函数是怎么实现的呢，很简单：

```
void make_youtiao(int num, func call_back) {
   // 制作油条
   call_back(); //执行回调
}
```

这样你就不用死盯着屏幕了，因为你把make\_youtiao这个函数执行完后该做的任务交代给make\_youtiao这个函数了，该函数制作完油条后知道该干些什么，这样就解放了你的程序。&#x20;

有的同学可能还是有疑问，为什么编写make\_youtiao这个小组不直接定义sell函数然后调用呢？

不要忘了明日油条这个App是由A小组和B小组同时开发的，A小组在编写make\_youtiao时怎么知道B小组要怎么用这个模块，假设A小组真的自己定义sell函数就会这样写：

```
void make_youtiao(int num) {
   real_make_youtiao(num);
   sell(); //执行回调
}
```

同时A小组设计的模块非常好用，这时C小组也想用这个模块，然而C小组的需求是制作完油条后放到仓库而不是不是直接卖掉，要满足这一需求那么A小组该怎么写呢？

```
void make_youtiao(int num) {
   real_make_youtiao(num);
    
   if (Team_B) {
       sell(); // 执行回调
   } else if (Team_D) {
       store(); // 放到仓库
   }
}
```

故事还没完，假设这时D小组又想使用呢，难道还要接着添加if else吗？这样的话A小组的同学只需要维护make\_youtiao这个函数就能做到工作量饱满了，显然这是一种非常糟糕的设计。

所以你会看到，制作完油条后接下来该做什么不是实现make\_youtiao的A小组该关心的事情，很明显只有调用make\_youtiao这个函数的使用方才知道。&#x20;

因此make\_youtiao的A小组完全可以通过回调函数将接下来该干什么交给调用方实现，A小组的同学只需要针对回调函数这一抽象概念进行编程就好了，这样调用方在制作完油条后不管是卖掉、放到库 存还是自己吃掉等等想做什么都可以，**A小组的make\_youtiao函数根本不用做任何改动**，因为A小组 是针对回调函数这一抽象概念来编程的。&#x20;

以上就是回调函数的作用，当然这也是针对抽象而不是具体实现进行编程这一思想的威力所在。面向对象中的多态本质上就是让你用来针对抽象而不是针对实现来编程的。

### 异步回调

故事到这里还没有结束。&#x20;

在上面的示例中，虽然我们使用了回调这一概念，也就是调用方实现回调函数然后再将该函数当做参数传递给其它模块调用。

但是，这里依然有一个问题，那就是make\_youtiao函数的调用方式依然是同步的，关于同步异步请参考《从小白到高手，你需要理解同步与异步》，也就是说调用方是这样实现的：

```
make_youtiao(10000, sell);
// make_youtiao函数返回前什么都做不了
```

![](.gitbook/assets/10_5.jpg)

我们可以看到，调用方必须等待make\_youtiao函数返回后才可以继续后续流程，我们再来看下make\_youtiao函数的实现：

```
void make_youtiao(int num, func call_back) {
   real_make_youtiao(num);
   call_back(); //执行回调
}
```

看到了吧，由于我们要制作10000个油条，make\_youtiao函数执行完需要10分钟，也就是说即便我们使用了回调，调用方完全不需要关心制作完油条后的后续流程，但是调用方依然会被阻塞10分钟，这就是同步调用的问题所在。&#x20;

如果你真的理解了上一节的话应该能想到一种更好的方法了。&#x20;

没错，那就是异步调用。&#x20;

反正制作完油条后的后续流程并不是调用方该关心的，也就是说调用方并不关心make\_youtiao这一函数的返回值，那么一种更好的方式是：把制作油条的这一任务放到另一个线程(进程)、甚至另一台机器上。&#x20;

如果用线程实现的话，那么make\_youtiao就是这样实现了:

```
void make_youtiao(int num, func call_back) {
   // 在新的线程中执行处理逻辑
   create_thread(real_make_youtiao,
                 num,
                 call_back);
}
```

![](.gitbook/assets/10_6.jpg)

看到了吧，这时当我们调用make\_youtiao时就会**立刻返回**，即使油条还没有真正开始制作，而调用方也完全无需等待制作油条的过程，可以立刻执行后流程：

```
make_youtiao(10000, sell);
// 立刻返回
// 执行后续流程
```

这时调用方的后续流程可以和制作油条**同时**进行，这就是函数的**异步调用**，当然这也是异步的高效之处。

### 新的编程思维模式&#x20;

让我们再来仔细的看一下这个过程。

程序员最熟悉的思维模式是这样的：

1. 调用某个函数，获取结果
2. 处理获取到的结果

```
res = request();
handle(res);
```

这就是函数的同步调用，只有request()函数返回拿到结果后，才能调用handle函数进行处理，request函数返回前我们必须等待，这就是同步调用，其控制流是这样的：

![](.gitbook/assets/10_7.jpg)

但是如果我们想更加高效的话，那么就需要异步调用了，我们不去直接调用handle函数，而是作为参数传递给request：

```
request(handle);
```

我们根本就不关心request什么时候真正的获取的结果，这是request该关心的事情，我们只需要把获取到结果后该怎么处理告诉request就可以了，因此request函数可以立刻返回，真的获取结果的处理可能是在另一个线程、进程、甚至另一台机器上完成。&#x20;

这就是异步调用，其控制流是这样的：

![](.gitbook/assets/10_8.jpg)

从编程思维上看，异步调用和同步有很大的差别，如果我们把处理流程当做一个任务来的话，那么同步下整个任务都是我们来实现的，但是异步情况下任务的处理流程被分为了两部分：

1. 第一部分是我们来处理的，也就是调用request之前的部分
2. 第二部分不是我们处理的，而是在其它线程、进程、甚至另一个机器上处理的。

我们可以看到由于任务被分成了两部分，第二部分的调用不在我们的掌控范围内，同时只有调用方才知道该做什么，因此在这种情况下回调函数就是一种必要的机制了。&#x20;

也就是说回调函数的本质就是“只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其它模块才知道，因此我们必须把我们知道的封装成回调函数告诉其它模块”。&#x20;

现在你应该能看出异步回调这种编程思维模式和同步的差异了吧。&#x20;

接下来我们给回调一个较为学术的定义

### 正式定义

_<mark style="background-color:blue;">在计算机科学中，回调函数是指一段以参数的形式传递给其它代码的可执行代码。</mark>_

这就是回调函数的定义了。&#x20;

回调函数就是一个函数，和其它函数没有任何区别。&#x20;

注意，回调函数是一种软件设计上的概念，和某个编程语言没有关系，几乎所有的编程语言都能实现回调函数。&#x20;

对于一般的函数来说，我们自己编写的函数会在自己的程序内部调用，也就是说函数的编写方是我们自己，调用方也是我们自己。&#x20;

但回调函数不是这样的，虽然函数编写方是我们自己，但是函数调用方不是我们，而是我们引用的其它模块，也就是第三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，第三方库中的函数调用我们编写的回调函数，如图所示：

![](.gitbook/assets/10_9.jpg)

而之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点，比如我们举的例子油条制作完成、接收到网络数据、文件读取完成等之后该做什么，这些只有库的使用方才知道，因此第三方库的编写者无法针对具体的实现来写代码，而只能对外提供一个回调函数，库的使用方来实现该函数，第三方库在特定的节点调用该回调函数就可以了。&#x20;

另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于**同一层**中，我们只负责编写该回调函数，但并不是我们来调用的。&#x20;

最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，也就是event，本质上我们编写的回调函数就是用来处理event的，因此从这个角度看回调函数不过就是event handler，因此回调函数天然适用于事件驱动编程event-driven，我们将会在后续文章中再次回到这一主题。

### 回调的类型

我们已经知道有两种类型的回调，这两种类型的回调区别在于回调函数被调用的时机。

_**同步回调**_

这种回调就是通常所说的同步回调synchronous callbacks、也有的将其称为阻塞式回调blockingcallbacks，或者什么修饰都没有，就是回调，callback，这是我们最为熟悉的回调方式。

当我们调用某个函数A并以参数的形式传入回调函数后，在A返回之前回调函数会被执行，也就是说我们的主程序会等待回调函数执行完成，这就是所谓的同步回调。

![](.gitbook/assets/10_10.jpg)

有同步回调就有异步回调。

_**异步回调**_

不同于同步回调， 当我们调用某个函数A并以参数的形式传入回调函数后，A函数会立刻返回，也就是说函数A并不会阻塞我们的主程序，一段时间后回调函数开始被执行，此时我们的主程序可能在忙其它任务，回调函数的执行和我们主程序的运行同时进行。

既然我们的主程序和回调函数的执行可以同时发生，因此一般情况下，主程序和回调函数的执行位于不同的线程或者进程中。

![](.gitbook/assets/10_11.jpg)

这就是所谓的异步回调，asynchronous callbacks，也有的资料将其称为deferred callbacks ，名字很形象，延迟回调。&#x20;

从上面这两张图中我们也可以看到，异步回调要比同步回调更能充分的利用机器资源，原因就在于在同步模式下主程序会“偷懒”，因为调用其它函数被阻塞而暂停运行，但是异步调用不存在这个问题，主程序会一直运行下去。&#x20;

因此，异步回调更常见于I/O操作，天然适用于Web服务这种高并发场景。

### 为什么异步回调这种思维模式正变得的越来越重要

在同步模式下，服务调用方会因服务执行而被阻塞暂停执行，这会导致整个线程被阻塞，因此这种编程方式天然不适用于高并发动辄几万几十万的并发连接场景，针对高并发这一场景，异步其实是更加高效的，原因很简单，你不需要在原地等待，因此从而更好的 利用机器资源，而回调函数又是异步下不可或缺的一种机制。

### 回调地狱，callback hell

有的同学可能认为有了异步回调这种机制应付起一切高并发场景就可以高枕无忧了。&#x20;

实际上在计算机科学中还没有任何一种可以横扫一切包治百病的技术，现在没有，在可预见的将来也不会有，一切都是妥协的结果。&#x20;

那么异步回调这种机制有什么问题呢？&#x20;

实际上我们已经看到了，异步回调这种机制和程序员最熟悉的同步模式不一样，在可理解性上比不过同步，而如果业务逻辑相对复杂，比如我们处理某项任务时不止需要调用一项服务，而是几项甚至十几项，如果这些服务调用都采用异步回调的方式来处理的话，那么很有可能我们就陷入回调地狱中。&#x20;

举个例子，假设处理某项任务我们需要调用四个服务，每一个服务都需要依赖上一个服务的结果，如果用同步方式来实现的话可能是这样的：

```
a = GetServiceA();
b = GetServiceB(a);
c = GetServiceC(b);
d = GetServiceD(c);
```

代码很清晰，很容易理解有没有。&#x20;

我们知道异步回调的方式会更加高效，那么使用异步回调的方式来写将会是什么样的呢？

```
GetServiceA(function(a){
   GetServiceB(a, function(b){
       GetServiceC(b, function(c){
           GetServiceD(c, function(d) {
               ....
           });
       });
   });
});
```

我想不需要再强调什么了吧，你觉得这两种写法哪个更容易理解，代码更容易维护呢？&#x20;

博主有幸曾经维护过这种类型的代码，不得不说每次增加新功能的时候恨不得自己化为两个分身，一个不得不去重读一边代码；另一个在一旁骂自己为什么当初选择维护这个项目。&#x20;

异步回调代码稍不留意就会跌到回调陷阱中，那么有没有一种更好的办法既能结合异步回调的高效又能结合同步编码的简单易读呢？&#x20;

幸运的是，答案是肯定的，我们会在后续文章中详细讲解这一技术。

### 总结

在这篇文章中，我们从一个实际的例子出发详细讲解了回调函数这种机制的来龙去脉，这是应对高并发、高性能场景的一种极其重要的编码机制，异步加回调可以充分利用机器资源，实际上异步回调最本质上就是事件驱动编程，这是我们接下来要重点讲解的内容。

